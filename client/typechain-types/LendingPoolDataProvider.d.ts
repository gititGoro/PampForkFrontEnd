/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import BN from "bn.js";
import { EventData, PastEventOptions } from "web3-eth-contract";

export interface LendingPoolDataProviderContract
  extends Truffle.Contract<LendingPoolDataProviderInstance> {
  "new"(
    meta?: Truffle.TransactionDetails
  ): Promise<LendingPoolDataProviderInstance>;
}

type AllEvents = never;

export interface LendingPoolDataProviderInstance
  extends Truffle.ContractInstance {
  DATA_PROVIDER_REVISION(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  HEALTH_FACTOR_LIQUIDATION_THRESHOLD(
    txDetails?: Truffle.TransactionDetails
  ): Promise<BN>;

  addressesProvider(txDetails?: Truffle.TransactionDetails): Promise<string>;

  core(txDetails?: Truffle.TransactionDetails): Promise<string>;

  initialize: {
    (
      _addressesProvider: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      _addressesProvider: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      _addressesProvider: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      _addressesProvider: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * calculates the user data across the reserves. this includes the total liquidity/collateral/borrow balances in ETH, the average Loan To Value, the average Liquidation Ratio, and the Health factor.
   * @param _user the address of the user
   * @returns the total liquidity, total collateral, total borrow balances of the user in ETH. also the average Ltv, liquidation threshold, and the health factor*
   */
  calculateUserGlobalData(
    _user: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<[BN, BN, BN, BN, BN, BN, BN, boolean]>;

  /**
   * check if a specific balance decrease is allowed (i.e. doesn't bring the user borrow position health factor under 1e18)
   * @param _amount the amount to decrease
   * @param _reserve the address of the reserve
   * @param _user the address of the user
   * @returns true if the decrease of the balance is allowed*
   */
  balanceDecreaseAllowed(
    _reserve: string,
    _user: string,
    _amount: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<boolean>;

  /**
   * calculates the amount of collateral needed in ETH to cover a new borrow.
   * @param _amount the amount the user wants to borrow
   * @param _fee the fee for the amount that the user needs to cover
   * @param _reserve the reserve from which the user wants to borrow
   * @param _userCurrentBorrowBalanceTH the current borrow balance of the user (before the borrow)
   * @param _userCurrentLtv the average ltv of the user given his current collateral
   * @returns the total amount of collateral in ETH to cover the current borrow balance + the new amount + fee*
   */
  calculateCollateralNeededInETH(
    _reserve: string,
    _amount: number | BN | string,
    _fee: number | BN | string,
    _userCurrentBorrowBalanceTH: number | BN | string,
    _userCurrentFeesETH: number | BN | string,
    _userCurrentLtv: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<BN>;

  /**
   * returns the health factor liquidation threshold*
   */
  getHealthFactorLiquidationThreshold(
    txDetails?: Truffle.TransactionDetails
  ): Promise<BN>;

  /**
   * accessory functions to fetch data from the lendingPoolCore*
   */
  getReserveConfigurationData(
    _reserve: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<[BN, BN, BN, string, boolean, boolean, boolean, boolean]>;

  getReserveData(
    _reserve: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<[BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, string, BN]>;

  getUserAccountData(
    _user: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<[BN, BN, BN, BN, BN, BN, BN, BN]>;

  getUserReserveData(
    _reserve: string,
    _user: string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<[BN, BN, BN, BN, BN, BN, BN, BN, BN, boolean]>;

  methods: {
    DATA_PROVIDER_REVISION(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    HEALTH_FACTOR_LIQUIDATION_THRESHOLD(
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;

    addressesProvider(txDetails?: Truffle.TransactionDetails): Promise<string>;

    core(txDetails?: Truffle.TransactionDetails): Promise<string>;

    initialize: {
      (
        _addressesProvider: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        _addressesProvider: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        _addressesProvider: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        _addressesProvider: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * calculates the user data across the reserves. this includes the total liquidity/collateral/borrow balances in ETH, the average Loan To Value, the average Liquidation Ratio, and the Health factor.
     * @param _user the address of the user
     * @returns the total liquidity, total collateral, total borrow balances of the user in ETH. also the average Ltv, liquidation threshold, and the health factor*
     */
    calculateUserGlobalData(
      _user: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<[BN, BN, BN, BN, BN, BN, BN, boolean]>;

    /**
     * check if a specific balance decrease is allowed (i.e. doesn't bring the user borrow position health factor under 1e18)
     * @param _amount the amount to decrease
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns true if the decrease of the balance is allowed*
     */
    balanceDecreaseAllowed(
      _reserve: string,
      _user: string,
      _amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<boolean>;

    /**
     * calculates the amount of collateral needed in ETH to cover a new borrow.
     * @param _amount the amount the user wants to borrow
     * @param _fee the fee for the amount that the user needs to cover
     * @param _reserve the reserve from which the user wants to borrow
     * @param _userCurrentBorrowBalanceTH the current borrow balance of the user (before the borrow)
     * @param _userCurrentLtv the average ltv of the user given his current collateral
     * @returns the total amount of collateral in ETH to cover the current borrow balance + the new amount + fee*
     */
    calculateCollateralNeededInETH(
      _reserve: string,
      _amount: number | BN | string,
      _fee: number | BN | string,
      _userCurrentBorrowBalanceTH: number | BN | string,
      _userCurrentFeesETH: number | BN | string,
      _userCurrentLtv: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;

    /**
     * returns the health factor liquidation threshold*
     */
    getHealthFactorLiquidationThreshold(
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;

    /**
     * accessory functions to fetch data from the lendingPoolCore*
     */
    getReserveConfigurationData(
      _reserve: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<[BN, BN, BN, string, boolean, boolean, boolean, boolean]>;

    getReserveData(
      _reserve: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<[BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, string, BN]>;

    getUserAccountData(
      _user: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<[BN, BN, BN, BN, BN, BN, BN, BN]>;

    getUserReserveData(
      _reserve: string,
      _user: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<[BN, BN, BN, BN, BN, BN, BN, BN, BN, boolean]>;
  };

  getPastEvents(event: string): Promise<EventData[]>;
  getPastEvents(
    event: string,
    options: PastEventOptions,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
  getPastEvents(event: string, options: PastEventOptions): Promise<EventData[]>;
  getPastEvents(
    event: string,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
}
