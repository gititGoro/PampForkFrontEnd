/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import BN from "bn.js";
import { EventData, PastEventOptions } from "web3-eth-contract";

export interface TokenDistributorContract
  extends Truffle.Contract<TokenDistributorInstance> {
  "new"(meta?: Truffle.TransactionDetails): Promise<TokenDistributorInstance>;
}

export interface Burn {
  name: "Burn";
  args: {
    amount: BN;
    0: BN;
  };
}

export interface Distributed {
  name: "Distributed";
  args: {
    receiver: string;
    percentage: BN;
    amount: BN;
    0: string;
    1: BN;
    2: BN;
  };
}

export interface DistributionUpdated {
  name: "DistributionUpdated";
  args: {
    receivers: string[];
    percentages: BN[];
    0: string[];
    1: BN[];
  };
}

export interface Setup {
  name: "Setup";
  args: {
    tokenToBurn: string;
    kyberProxy: string;
    _recipientBurn: string;
    0: string;
    1: string;
    2: string;
  };
}

export interface Trade {
  name: "Trade";
  args: {
    from: string;
    fromAmount: BN;
    toAmount: BN;
    0: string;
    1: BN;
    2: BN;
  };
}

type AllEvents = Burn | Distributed | DistributionUpdated | Setup | Trade;

export interface TokenDistributorInstance extends Truffle.ContractInstance {
  DISTRIBUTION_BASE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  IMPLEMENTATION_REVISION(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  KYBER_ETH_MOCK_ADDRESS(
    txDetails?: Truffle.TransactionDetails
  ): Promise<string>;

  MAX_UINT(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MAX_UINT_MINUS_ONE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MIN_CONVERSION_RATE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  kyberProxy(txDetails?: Truffle.TransactionDetails): Promise<string>;

  recipientBurn(txDetails?: Truffle.TransactionDetails): Promise<string>;

  tokenToBurn(txDetails?: Truffle.TransactionDetails): Promise<string>;

  /**
   * Called by the proxy when setting this contract as implementation
   */
  initialize: {
    (
      _recipientBurn: string,
      _tokenToBurn: string,
      _kyberProxy: string,
      _receivers: string[],
      _percentages: (number | BN | string)[],
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      _recipientBurn: string,
      _tokenToBurn: string,
      _kyberProxy: string,
      _receivers: string[],
      _percentages: (number | BN | string)[],
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      _recipientBurn: string,
      _tokenToBurn: string,
      _kyberProxy: string,
      _receivers: string[],
      _percentages: (number | BN | string)[],
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      _recipientBurn: string,
      _tokenToBurn: string,
      _kyberProxy: string,
      _receivers: string[],
      _percentages: (number | BN | string)[],
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Distributes a list of _tokens balances in this contract, depending on the distribution
   * @param _tokens list of ERC20 tokens to distribute
   */
  distribute: {
    (_tokens: string[], txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * "Infinite" approval for all the tokens initialized
   * @param _tokens List of IERC20 to approve
   */
  approveKyber: {
    (_tokens: string[], txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      _tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Returns the receivers and percentages of the contract Distribution
   * @returns receivers array of addresses and percentages array on uints
   */
  getDistribution(
    txDetails?: Truffle.TransactionDetails
  ): Promise<[string[], BN[]]>;

  methods: {
    DISTRIBUTION_BASE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    IMPLEMENTATION_REVISION(
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;

    KYBER_ETH_MOCK_ADDRESS(
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;

    MAX_UINT(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MAX_UINT_MINUS_ONE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MIN_CONVERSION_RATE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    kyberProxy(txDetails?: Truffle.TransactionDetails): Promise<string>;

    recipientBurn(txDetails?: Truffle.TransactionDetails): Promise<string>;

    tokenToBurn(txDetails?: Truffle.TransactionDetails): Promise<string>;

    /**
     * Called by the proxy when setting this contract as implementation
     */
    initialize: {
      (
        _recipientBurn: string,
        _tokenToBurn: string,
        _kyberProxy: string,
        _receivers: string[],
        _percentages: (number | BN | string)[],
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        _recipientBurn: string,
        _tokenToBurn: string,
        _kyberProxy: string,
        _receivers: string[],
        _percentages: (number | BN | string)[],
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        _recipientBurn: string,
        _tokenToBurn: string,
        _kyberProxy: string,
        _receivers: string[],
        _percentages: (number | BN | string)[],
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        _recipientBurn: string,
        _tokenToBurn: string,
        _kyberProxy: string,
        _receivers: string[],
        _percentages: (number | BN | string)[],
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Distributes a list of _tokens balances in this contract, depending on the distribution
     * @param _tokens list of ERC20 tokens to distribute
     */
    distribute: {
      (_tokens: string[], txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * "Infinite" approval for all the tokens initialized
     * @param _tokens List of IERC20 to approve
     */
    approveKyber: {
      (_tokens: string[], txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        _tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Returns the receivers and percentages of the contract Distribution
     * @returns receivers array of addresses and percentages array on uints
     */
    getDistribution(
      txDetails?: Truffle.TransactionDetails
    ): Promise<[string[], BN[]]>;
  };

  getPastEvents(event: string): Promise<EventData[]>;
  getPastEvents(
    event: string,
    options: PastEventOptions,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
  getPastEvents(event: string, options: PastEventOptions): Promise<EventData[]>;
  getPastEvents(
    event: string,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
}
